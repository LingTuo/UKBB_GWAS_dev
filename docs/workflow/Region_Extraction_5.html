<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="ipynb_website:version" content="0.9.7" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" type="text/css" href="../css/jt.css">

<link rel="stylesheet" type="text/css" href="../css/toc2.css">

<link href="../site_libs/jqueryui-1.11.4/jquery-ui.css">
<link rel="stylesheet" href="../site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<link rel="stylesheet" href="../site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<link rel="stylesheet"
      href="../site_libs/highlightjs/null.min.css"
      type="text/css" />

<script src="../site_libs/highlightjs/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>

<script src="../js/doc_toc.js"></script>
<script src="../js/docs.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": {
            preferredFont: "TeX",
            availableFonts: ["TeX"],
            styles: {
                scale: 110,
                ".MathJax_Display": {
                    "font-size": "110%",
                }
            }
        }
    });
</script>
<script>
function filterDataFrame(id) {
    var input = document.getElementById("search_" + id);
    var filter = input.value.toUpperCase();
    var table = document.getElementById("dataframe_" + id);
    var tr = table.getElementsByTagName("tr");
    // Loop through all table rows, and hide those who don't match the search query
    for (var i = 1; i < tr.length; i++) {
        for (var j = 0; j < tr[i].cells.length; ++j) {
            var matched = false;
            if (tr[i].cells[j].innerHTML.toUpperCase().indexOf(filter) != -1) {
                tr[i].style.display = "";
                matched = true
                break;
            }
            if (!matched)
                tr[i].style.display = "none";
        }
    }
}
function sortDataFrame(id, n, dtype) {
    var table = document.getElementById("dataframe_" + id);
    var tb = table.tBodies[0]; // use `<tbody>` to ignore `<thead>` and `<tfoot>` rows
    var tr = Array.prototype.slice.call(tb.rows, 0); // put rows into array
    if (dtype === 'numeric') {
        var fn = function(a, b) { 
            return parseFloat(a.cells[n].textContent) <= parseFloat(b.cells[n].textContent) ? -1 : 1;
        }
    } else {
        var fn = function(a, b) {
            var c = a.cells[n].textContent.trim().localeCompare(b.cells[n].textContent.trim()); 
            return c > 0 ? 1 : (c < 0 ? -1 : 0) }
    }
    var isSorted = function(array, fn) {
        if (array.length < 2)
            return 1;
        var direction = fn(array[0], array[1]); 
        for (var i = 1; i < array.length - 1; ++i) {
            var d = fn(array[i], array[i+1]);
            if (d == 0)
                continue;
            else if (direction == 0)
                direction = d;
            else if (direction != d)
                return 0;
            }
        return direction;
    }
    var sorted = isSorted(tr, fn);
    if (sorted == 1 || sorted == -1) {
        // if sorted already, reverse it
        for(var i = tr.length - 1; i >= 0; --i)
            tb.appendChild(tr[i]); // append each row in order
    } else {
        tr = tr.sort(fn);
        for(var i = 0; i < tr.length; ++i)
            tb.appendChild(tr[i]); // append each row in order
    }
}
</script>

<script>
$( document ).ready(function(){
            var cfg={'threshold':3,     // depth of toc (number of levels)
             'number_sections': false,
             'toc_cell': false,          // useless here
             'toc_window_display': true, // display the toc window
             "toc_section_display": "block", // display toc contents in the window
             'sideBar':true,       // sidebar or floating window
             'navigate_menu':false       // navigation menu (only in liveNotebook -- do not change)
            }
            var st={};                  // some variables used in the script
            st.rendering_toc_cell = false;
            st.config_loaded = false;
            st.extension_initialized=false;
            st.nbcontainer_marginleft = $('#notebook-container').css('margin-left')
            st.nbcontainer_marginright = $('#notebook-container').css('margin-right')
            st.nbcontainer_width = $('#notebook-container').css('width')
            st.oldTocHeight = undefined
            st.cell_toc = undefined;
            st.toc_index=0;
            // fire the main function with these parameters
            table_of_contents(cfg, st);
            var file=workflowDict[$("h1:first").attr("id")];
            $("#toc-level0 a").css("color","#126dce");
            $('a[href="#'+$("h1:first").attr("id")+'"]').hide()
            var docs=workflowArray;
            var docs_map=workflowArrayMap;
            var pos=workflowArray.indexOf(file);
            for (var a=pos;a>=0;a--){
                  $('<li><a href="'+docs[a]+'.html"><font color="#073642"><b>'+docs_map[docs[a]].replace(/_/g," ")+'</b></font></a></li>').insertBefore("#toc-level0 li:eq(0)");
            }
            $('a[href="'+file+'.html'+'"]').css("color","#126dce");
            for (var a=pos+1;a<docs.length;a++){
                  $(".toc #toc-level0").append('<li><a href="'+docs[a]+'.html"><font color="#073642"><b>'+docs_map[docs[a]].replace(/_/g," ")+'</b></font></a></li>');
            }
            // $("#toc-header").hide(); // comment out because it prevents search bar from displaying
    });
</script>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');
  // mark it active
  menuAnchor.parent().addClass('active');
  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>
<div class="container-fluid main-container">
<!-- tabsets -->
<script src="../site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>



<title>Pleiotropy analysis in UKBB</title>

<style type = "text/css">
body {
  font-family: "Droid Sans";
  padding-top: 66px;
  padding-bottom: 40px;
}
</style>
</head>

<body>
<div tabindex="-1" id="notebook" class="border-box-sizing">
<div class="container" id="notebook-container">

<!-- code folding -->

<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">Pleiotropy analysis in UKBB</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
<li>
  <a href="../index.html">Overview</a>
</li>
        
<li>
  <a href="../workflow.html">Workflow</a>
</li>
        
<li>
  <a href="../analysis.html">Analysis</a>
</li>
        
      </ul>
        
<ul class="nav navbar-nav navbar-right">
<li>
   <a href="http://github.com/dianacornejo/pleiotropy_UKB"> <span class="fa fa-github"></span> </a>
</li>
</ul>
        
      </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Extracting-data-for-genomic-regions-of-interest">Extracting data for genomic regions of interest<a class="anchor-link" href="#Extracting-data-for-genomic-regions-of-interest">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Aim">Aim<a class="anchor-link" href="#Aim">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To extract the summary statistics and genotype on specific genomic regions and calculate their LD matrix.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Pre-requisites">Pre-requisites<a class="anchor-link" href="#Pre-requisites">&#182;</a></h2><p>Make sure you install the pre-requisited before running this notebook:</p>

<pre><code>pip install pybgen
pip install pandas_plink
pip install scipy</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Input-and-Output">Input and Output<a class="anchor-link" href="#Input-and-Output">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Input">Input<a class="anchor-link" href="#Input">&#182;</a></h3><ul>
<li><code>--region-file</code>, including a list of regions<ul>
<li>Each locus will be represented by one line in the region file with 3 columns chr, start, and end. e.g. <code>7 27723990 28723990</code></li>
</ul>
</li>
<li><code>--geno-path</code>, the path of a genotype inventory, which lists the path of all genotype file in <code>bgen</code> format or in <code>plink</code> format.<ul>
<li>The list is a file with 2 columns: <code>chr genotype_file_chr.ext</code>. </li>
<li>The first column is chromosome ID, the 2nd file is genotype for that chromosome.</li>
<li>When chromosome ID is 0, it implies that the genotype file contains all the genotypes.</li>
</ul>
</li>
<li><code>--pheno-path</code>, the path of a phenotype.<ul>
<li>The phenotype file should have a column with the name <code>IID</code>, which is used to represent the sample ID.</li>
</ul>
</li>
<li><code>--bgen-sample-path</code>, the path of a file including the sample in the <code>bgen</code> files.<ul>
<li>If the genotype file is in <code>bgen</code> format, you should provide this path.</li>
</ul>
</li>
<li><code>--sumstats-path</code>, the path of the GWAS file, including all summary statistics (eg, $\hat{\beta}$, $SE(\hat{\beta})$ and p-values)<ul>
<li>These summary statistics should contain at least these columns: <code>chrom, pos, ref, alt, snp_id, bhat, sbhat, p</code></li>
</ul>
</li>
<li><code>--unrelated-samples</code>, the file path of unrelated samples with a column named <code>IID</code>.   </li>
<li><code>--cwd</code>, the path of output directory</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Output">Output<a class="anchor-link" href="#Output">&#182;</a></h3><ul>
<li><code>rg_stat</code>, the reginonal summary stats<ul>
<li>The rowname is the variant ID.</li>
<li>It should contain at least the following columns: <code>CHR, BP, SNP, ALT, REF, BETA, SE, Z, P</code>.</li>
</ul>
</li>
<li><code>rg_geno</code>,the regional genotypes<ul>
<li>The rowname is the variant ID, which should match with the rowname of <code>rg_stat</code>.</li>
<li>The column name is the sample's IID, which is sorted by the sample in phenotype.</li>
</ul>
</li>
<li><code>pld</code>, the regional approximate population LD calculated by unrelated individuals</li>
<li><code>sld</code>, the regional approximate sample LD calcualted by unrelated individuals in a phenotype.</li>
<li><code>chr*_extract_variant_number.txt</code>, bash scripts to extact variant numbers of each region for each chromosome. - e.g. use command : <code>bash chr20_extract_variant_number.txt</code> </li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Workflow-usage">Workflow usage<a class="anchor-link" href="#Workflow-usage">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Using our minimal working example data-set where we have already generated results for fastGWA,</p>

<pre><code>sos run Region_Extraction.ipynb \
    --cwd candidate_loci \
    --region-file data/regions.txt \
    --pheno-path data/phenotypes.txt \
    --geno-path data/genotype_inventory.txt \
    --bgen-sample-path data/imputed_genotypes.sample \
    --sumstats-path output/phenotypes_BMI.fastGWA.snp_stats.gz \
    --unrelated-samples data/unrelated_samples.txt \
    --job-size 1</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-bash"><pre><span></span><span class="o">[</span>global<span class="o">]</span>
<span class="c1"># Work directory where output will be saved to</span>
parameter: <span class="nv">cwd</span> <span class="o">=</span> path
<span class="c1"># Region specifications</span>
parameter: <span class="nv">region_file</span> <span class="o">=</span> path
<span class="c1"># Genotype file inventory</span>
parameter: <span class="nv">geno_path</span> <span class="o">=</span> path
<span class="c1"># Phenotype path</span>
parameter: <span class="nv">pheno_path</span> <span class="o">=</span> path
<span class="c1"># Sample file path, for bgen format</span>
parameter: <span class="nv">bgen_sample_path</span> <span class="o">=</span> path<span class="o">(</span><span class="s1">&#39;.&#39;</span><span class="o">)</span>
<span class="c1"># Path to summary stats file</span>
parameter: <span class="nv">sumstats_path</span> <span class="o">=</span> path
<span class="c1"># Path to summary stats format configuration</span>
parameter: <span class="nv">format_config_path</span> <span class="o">=</span> path<span class="o">(</span><span class="s1">&#39;.&#39;</span><span class="o">)</span>
<span class="c1"># Path to samples of unrelated individuals</span>
parameter: <span class="nv">unrelated_samples</span> <span class="o">=</span> path
<span class="c1"># Number of tasks to run in each job on cluster</span>
parameter: <span class="nv">job_size</span> <span class="o">=</span> int
parameter: <span class="nv">container_lmm</span> <span class="o">=</span> <span class="s1">&#39;/home/hs863/LMM/lmm_v_1_3.sif&#39;</span>
<span class="c1">#parameter: container_lmm = &#39;statisticalgenetics/lmm:1.4&#39;</span>

    
fail_if<span class="o">(</span>not region_file.is_file<span class="o">()</span>, <span class="nv">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot find regions to extract. Please specify them using ``--region-file`` option.&#39;</span><span class="o">)</span>
<span class="c1"># Load all regions of interest. Each item in the list will be a region: (chr, start, end)</span>
<span class="nv">regions</span> <span class="o">=</span> list<span class="o">(</span>set<span class="o">([</span>tuple<span class="o">(</span>x.strip<span class="o">()</span>.split<span class="o">())</span> <span class="k">for</span> x in open<span class="o">(</span>region_file<span class="o">)</span>.readlines<span class="o">()</span> <span class="k">if</span> x.strip<span class="o">()]))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Workflow-codes">Workflow codes<a class="anchor-link" href="#Workflow-codes">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Some-utility-functions">Some utility functions<a class="anchor-link" href="#Some-utility-functions">&#182;</a></h2><ul>
<li><code>plink_slice</code>: The function of extracting regional genotype<ul>
<li>p: list of bim, fam, bed</li>
<li>pb: index of bim</li>
<li>pf: index of fam</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-bash"><pre><span></span><span class="o">[</span>default_1 <span class="o">(</span><span class="nb">export</span> utils script<span class="o">)]</span>
report: <span class="nv">container</span><span class="o">=</span>container_lmm, <span class="nv">expand</span> <span class="o">=</span> <span class="s1">&#39;${ }&#39;</span>, <span class="nv">output</span><span class="o">=</span>f<span class="s1">&#39;{cwd:a}/utils.py&#39;</span>

    import memory_profiler
    from memory_profiler import profile

    import numpy as np
    import pandas as pd
    from xxhash import xxh32 as xxh
    def shorten_id<span class="o">(</span>x<span class="o">)</span>:
        <span class="k">return</span> x <span class="k">if</span> len<span class="o">(</span>x<span class="o">)</span> &lt; <span class="m">30</span> <span class="k">else</span> f<span class="s2">&quot;{x.split(&#39;_&#39;)[0]}_{xxh(x).hexdigest()}&quot;</span>
    
    def read_sumstat<span class="o">(</span>file, config_file<span class="o">)</span>:
        <span class="nv">sumstats</span> <span class="o">=</span> pd.read_csv<span class="o">(</span>file, <span class="nv">compression</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span>, <span class="nv">header</span><span class="o">=</span><span class="m">0</span>, <span class="nv">sep</span><span class="o">=</span><span class="s1">&#39;\t&#39;</span>, <span class="nv">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="o">)</span>
        <span class="k">if</span> config_file is not None:
            import yaml
            <span class="nv">config</span> <span class="o">=</span> yaml.safe_load<span class="o">(</span>open<span class="o">(</span>config_file, <span class="s1">&#39;r&#39;</span><span class="o">))</span>
            try:
                <span class="nv">sumstats</span> <span class="o">=</span> sumstats.loc<span class="o">[</span>:,list<span class="o">(</span>config.values<span class="o">())]</span>
            except:
                raise ValueError<span class="o">(</span>f<span class="s1">&#39;According to {config_file}, input summary statistics should have the following columns: {list(config.values())}.&#39;</span><span class="o">)</span>
            sumstats.columns <span class="o">=</span> list<span class="o">(</span>config.keys<span class="o">())</span>
        sumstats.SNP <span class="o">=</span> sumstats.SNP.apply<span class="o">(</span>shorten_id<span class="o">)</span>
        sumstats.CHR <span class="o">=</span> sumstats.CHR.astype<span class="o">(</span>int<span class="o">)</span> 
        sumstats.POS <span class="o">=</span> sumstats.POS.astype<span class="o">(</span>int<span class="o">)</span>
        <span class="k">return</span> sumstats
    
    def regional_stats<span class="o">(</span>sumstats, region<span class="o">)</span>:
        <span class="nv">ss</span> <span class="o">=</span> sumstats<span class="o">[(</span>sumstats.CHR <span class="o">==</span> region<span class="o">[</span><span class="m">0</span><span class="o">])</span> <span class="p">&amp;</span> <span class="o">(</span>sumstats.POS &gt;<span class="o">=</span> region<span class="o">[</span><span class="m">1</span><span class="o">])</span> <span class="p">&amp;</span> <span class="o">(</span>sumstats.POS &lt;<span class="o">=</span> region<span class="o">[</span><span class="m">2</span><span class="o">])]</span>
        ss.loc<span class="o">[</span>:,<span class="s1">&#39;Z&#39;</span><span class="o">]</span> <span class="o">=</span> p2z<span class="o">(</span>ss.P,ss.BETA<span class="o">)</span>
        <span class="k">return</span> ss
    
    from scipy.stats import norm
    def p2z<span class="o">(</span>pval,beta,twoside<span class="o">=</span>True<span class="o">)</span>:
        <span class="k">if</span> twoside:
            <span class="nv">pval</span> <span class="o">=</span> pval/2 
        <span class="nv">z</span><span class="o">=</span>np.abs<span class="o">(</span>norm.ppf<span class="o">(</span>pval<span class="o">))</span>
        <span class="nv">ind</span><span class="o">=</span>beta&lt;<span class="m">0</span>
        z<span class="o">[</span>ind<span class="o">]=</span>-z<span class="o">[</span>ind<span class="o">]</span>
        <span class="k">return</span> z
    
    def plink_slice<span class="o">(</span>p,pb<span class="o">=</span>None,pf<span class="o">=</span>None<span class="o">)</span>:
        <span class="o">(</span>bim,fam,bed<span class="o">)=</span>p
        <span class="k">if</span> pb is not None:
            <span class="nv">bim</span> <span class="o">=</span> bim.iloc<span class="o">[</span>pb<span class="o">]</span>
            <span class="nv">bed</span> <span class="o">=</span> bed<span class="o">[</span>pb,:<span class="o">]</span>
        <span class="k">if</span> pf is not None:
            <span class="nv">fam</span> <span class="o">=</span> fam.iloc<span class="o">[</span>pf<span class="o">]</span>
            <span class="nv">bed</span> <span class="o">=</span> bed<span class="o">[</span>:,pf<span class="o">]</span>
        <span class="nv">bed</span> <span class="o">=</span> bed.compute<span class="o">(</span><span class="nv">num_workers</span><span class="o">=</span><span class="m">1</span><span class="o">)</span>
        <span class="k">return</span><span class="o">(</span>bim,fam,bed<span class="o">)</span>
    
    def LD_matrix<span class="o">(</span>bed<span class="o">)</span>:
        <span class="nv">snps</span> <span class="o">=</span> pd.DataFrame<span class="o">(</span>bed.transpose<span class="o">())</span>
        <span class="c1"># use mean imputation to fill missing first, before computing correlations</span>
        <span class="nv">ld</span> <span class="o">=</span> snps.fillna<span class="o">(</span> snps.mean<span class="o">()</span> <span class="o">)</span>.corr<span class="o">()</span>
        <span class="k">return</span> ld
        
    def bgen_region<span class="o">(</span>region,geno,dtype<span class="o">=</span><span class="s1">&#39;float16&#39;</span><span class="o">)</span>:
        import numpy.ma as ma
        snps,genos<span class="o">=[]</span>,<span class="o">[]</span>
        <span class="nv">i</span><span class="o">=</span><span class="m">0</span>
        <span class="k">for</span> t,g in geno<span class="o">[</span><span class="m">0</span><span class="o">]</span>.iter_variants_in_region<span class="o">(</span><span class="s1">&#39;0&#39;</span>+str<span class="o">(</span>region<span class="o">[</span><span class="m">0</span><span class="o">])</span> <span class="k">if</span> region<span class="o">[</span><span class="m">0</span><span class="o">]</span>&lt;<span class="m">10</span> <span class="k">else</span> str<span class="o">(</span>region<span class="o">[</span><span class="m">0</span><span class="o">])</span>,region<span class="o">[</span><span class="m">1</span><span class="o">]</span>,region<span class="o">[</span><span class="m">2</span><span class="o">])</span>:
            snps.append<span class="o">([</span>int<span class="o">(</span>t.chrom<span class="o">)</span>,t.name,0.0,t.pos,t.a1,t.a2,i<span class="o">])</span>
            genos.append<span class="o">(</span>g.astype<span class="o">(</span>dtype<span class="o">))</span>
            <span class="nv">i</span><span class="o">+=</span><span class="m">1</span>
            
        <span class="k">return</span><span class="o">(</span>pd.DataFrame<span class="o">(</span>snps,columns<span class="o">=[</span><span class="s1">&#39;chrom&#39;</span>,<span class="s1">&#39;snp&#39;</span>,<span class="s1">&#39;cm&#39;</span>,<span class="s1">&#39;pos&#39;</span>,<span class="s1">&#39;a0&#39;</span>,<span class="s1">&#39;a1&#39;</span>,<span class="s1">&#39;i&#39;</span><span class="o">])</span>,np.array<span class="o">(</span>genos<span class="o">))</span>
    
    def check_unique<span class="o">(</span>idx, variable<span class="o">)</span>:
        <span class="k">if</span> idx.duplicated<span class="o">()</span>.any<span class="o">()</span>:
            raise ValueError<span class="o">(</span>f<span class="s2">&quot;{variable} index has duplicated elements!&quot;</span><span class="o">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Extract-data">Extract data<a class="anchor-link" href="#Extract-data">&#182;</a></h2><p>This step runs in parallel for all loci listed in the region file (via <code>for_each</code>).</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-bash"><pre><span></span><span class="o">[</span>default_2 <span class="o">(</span>extract genotypes<span class="o">)]</span>
input: geno_path, pheno_path, sumstats_path, unrelated_samples, <span class="nv">for_each</span> <span class="o">=</span> <span class="s1">&#39;regions&#39;</span>
output: <span class="nv">sumstats</span> <span class="o">=</span> f<span class="s1">&#39;{cwd:a}/{_regions[0]}_{_regions[1]}_{_regions[2]}/{sumstats_path:bn}_{_regions[0]}_{_regions[1]}_{_regions[2]}.sumstats.gz&#39;</span>,
        <span class="nv">genotype</span> <span class="o">=</span> f<span class="s1">&#39;{cwd:a}/{_regions[0]}_{_regions[1]}_{_regions[2]}/{sumstats_path:bn}_{_regions[0]}_{_regions[1]}_{_regions[2]}.genotype.gz&#39;</span>,
        <span class="nv">pld</span> <span class="o">=</span> f<span class="s1">&#39;{cwd:a}/{_regions[0]}_{_regions[1]}_{_regions[2]}/{sumstats_path:bn}_{_regions[0]}_{_regions[1]}_{_regions[2]}.population_ld.gz&#39;</span>,
        <span class="nv">sld</span> <span class="o">=</span> f<span class="s1">&#39;{cwd:a}/{_regions[0]}_{_regions[1]}_{_regions[2]}/{sumstats_path:bn}_{_regions[0]}_{_regions[1]}_{_regions[2]}.sample_ld.gz&#39;</span>,
        <span class="nv">general</span> <span class="o">=</span> f<span class="s1">&#39;{cwd:a}/{_regions[0]}_{_regions[1]}_{_regions[2]}/{sumstats_path:bn}_{_regions[0]}_{_regions[1]}_{_regions[2]}&#39;</span>
task: <span class="nv">trunk_workers</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">trunk_size</span> <span class="o">=</span> job_size, <span class="nv">walltime</span> <span class="o">=</span> <span class="s1">&#39;4h&#39;</span>, <span class="nv">mem</span> <span class="o">=</span> <span class="s1">&#39;64G&#39;</span>, <span class="nv">cores</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">tags</span> <span class="o">=</span> f<span class="s1">&#39;{step_name}_{_output[0]:bn}&#39;</span>
python: <span class="nv">container</span><span class="o">=</span>container_lmm , <span class="nv">expand</span> <span class="o">=</span> <span class="s1">&#39;${ }&#39;</span>, <span class="nv">input</span> <span class="o">=</span> f<span class="s1">&#39;{cwd:a}/utils.py&#39;</span>, <span class="nv">stderr</span> <span class="o">=</span> f<span class="s1">&#39;{_output[0]:n}.stderr&#39;</span>, <span class="nv">stdout</span> <span class="o">=</span> f<span class="s1">&#39;{_output[0]:n}.stdout&#39;</span>
    
    @profile
    def main<span class="o">()</span>:
        <span class="c1"># Load the file of summary statistics and standardize it.</span>
        <span class="nv">sumstats</span> <span class="o">=</span> read_sumstat<span class="o">(</span><span class="si">${</span><span class="nv">_input</span><span class="p">[2]:</span><span class="nv">r</span><span class="si">}</span>, <span class="si">${</span><span class="nv">format_config_path</span><span class="p">:</span><span class="nv">r</span><span class="si">}</span> <span class="k">if</span> <span class="si">${</span><span class="nv">format_config_path</span><span class="p">.is_file()</span><span class="si">}</span> <span class="k">else</span> None<span class="o">)</span>

        <span class="c1"># Load phenotype file</span>
        <span class="nv">pheno</span> <span class="o">=</span> pd.read_csv<span class="o">(</span><span class="si">${</span><span class="nv">_input</span><span class="p">[1]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">header</span><span class="o">=</span><span class="m">0</span>, <span class="nv">delim_whitespace</span><span class="o">=</span>True, <span class="nv">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="o">)</span>
        <span class="c1"># Load unrelated sample file</span>
        <span class="nv">unr</span> <span class="o">=</span> pd.read_csv<span class="o">(</span><span class="si">${</span><span class="nv">_input</span><span class="p">[3]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">header</span><span class="o">=</span><span class="m">0</span>, <span class="nv">delim_whitespace</span><span class="o">=</span>True, <span class="nv">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="o">)</span>
    
        <span class="c1"># Load genotype file for the region of interest</span>
        <span class="nv">geno_inventory</span> <span class="o">=</span> dict<span class="o">([</span>x.strip<span class="o">()</span>.split<span class="o">()</span> <span class="k">for</span> x in open<span class="o">(</span><span class="si">${</span><span class="nv">_input</span><span class="p">[0]:</span><span class="nv">r</span><span class="si">}</span><span class="o">)</span>.readlines<span class="o">()</span> <span class="k">if</span> x.strip<span class="o">()])</span>
        <span class="nv">chrom</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">_regions</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> chrom.startswith<span class="o">(</span><span class="s1">&#39;chr&#39;</span><span class="o">)</span>:
            <span class="nv">chrom</span> <span class="o">=</span> chrom<span class="o">[</span><span class="m">3</span>:<span class="o">]</span>
        <span class="k">if</span> chrom not in geno_inventory:
            <span class="nv">geno_file</span> <span class="o">=</span> geno_inventory<span class="o">[</span><span class="s1">&#39;0&#39;</span><span class="o">]</span>
        <span class="k">else</span>:
            <span class="nv">geno_file</span> <span class="o">=</span> geno_inventory<span class="o">[</span>chrom<span class="o">]</span>
        import os
        <span class="k">if</span> not os.path.isfile<span class="o">(</span>geno_file<span class="o">)</span>:
            <span class="c1"># relative path</span>
            <span class="k">if</span> not os.path.isfile<span class="o">(</span><span class="s1">&#39;${_input[0]:ad}/&#39;</span> + geno_file<span class="o">)</span>:
                raise ValueError<span class="o">(</span>f<span class="s2">&quot;Cannot find genotype file {geno_file}&quot;</span><span class="o">)</span>
            <span class="k">else</span>:
                <span class="nv">geno_file</span> <span class="o">=</span> <span class="s1">&#39;${_input[0]:ad}/&#39;</span> + geno_file
        <span class="k">if</span> geno_file.endswith<span class="o">(</span><span class="s1">&#39;.bed&#39;</span><span class="o">)</span>:
            <span class="nv">plink</span> <span class="o">=</span> True
            from pandas_plink import read_plink
            <span class="nv">geno</span> <span class="o">=</span> read_plink<span class="o">(</span>geno_file<span class="o">)</span>
        <span class="k">elif</span> geno_file.endswith<span class="o">(</span><span class="s1">&#39;.bgen&#39;</span><span class="o">)</span>:
            <span class="nv">plink</span> <span class="o">=</span> False
            from pybgen import PyBGEN
            <span class="nv">bgen</span> <span class="o">=</span> PyBGEN<span class="o">(</span>geno_file<span class="o">)</span>
            <span class="nv">sample_file</span> <span class="o">=</span> geno_file.replace<span class="o">(</span><span class="s1">&#39;.bgen&#39;</span>, <span class="s1">&#39;.sample&#39;</span><span class="o">)</span>
            <span class="k">if</span> not os.path.isfile<span class="o">(</span>sample_file<span class="o">)</span>:
                <span class="k">if</span> not os.path.isfile<span class="o">(</span><span class="si">${</span><span class="nv">bgen_sample_path</span><span class="p">:</span><span class="nv">r</span><span class="si">}</span><span class="o">)</span>:
                    raise ValueError<span class="o">(</span>f<span class="s2">&quot;Cannot find the matching sample file ``{sample_file}`` for ``{geno_file}``.\nYou can specify path to sample file for all BGEN files using ``--bgen-sample-path``.&quot;</span><span class="o">)</span>
                <span class="k">else</span>:
                    <span class="nv">sample_file</span> <span class="o">=</span> <span class="si">${</span><span class="nv">bgen_sample_path</span><span class="p">:</span><span class="nv">r</span><span class="si">}</span>
            <span class="nv">bgen_fam</span> <span class="o">=</span> pd.read_csv<span class="o">(</span>sample_file, <span class="nv">header</span><span class="o">=</span><span class="m">0</span>, <span class="nv">delim_whitespace</span><span class="o">=</span>True, <span class="nv">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span>,skiprows<span class="o">=</span><span class="m">1</span><span class="o">)</span>
            bgen_fam.columns <span class="o">=</span> <span class="o">[</span><span class="s1">&#39;fid&#39;</span>,<span class="s1">&#39;iid&#39;</span>,<span class="s1">&#39;missing&#39;</span>,<span class="s1">&#39;sex&#39;</span><span class="o">]</span>
            <span class="nv">geno</span> <span class="o">=</span> <span class="o">[</span>bgen,bgen_fam<span class="o">]</span>
        <span class="k">else</span>:
            raise ValueError<span class="o">(</span><span class="s1">&#39;Plesae provide the genotype files with PLINK binary format or BGEN format&#39;</span><span class="o">)</span>
    
    
        <span class="c1"># REWRITING EXTRACT REGION HERE</span>
        import gc
        import <span class="nb">time</span>
        <span class="nv">t</span> <span class="o">=</span> time.localtime<span class="o">()</span>
        <span class="c1"># Extract the summary stat</span>
        print<span class="o">(</span>f<span class="s1">&#39;{time.strftime(&quot;%H:%M:%S&quot;, t)}: Extracting summary statistics ...&#39;</span><span class="o">)</span>
        
        <span class="c1"># chose the method of incrementing the regions by a certain amount and then doing all checking calculations to decrease</span>
        <span class="c1"># the time it takes for execution and to decrease the likelihood of reaching the memory capacity</span>
        
        <span class="nv">region_inc</span> <span class="o">=</span> <span class="m">100000</span> <span class="c1"># size of the incrementer we will be doing</span>
        <span class="nv">curr_region_lbound</span> <span class="o">=</span> <span class="si">${</span><span class="nv">_regions</span><span class="p">[1]</span><span class="si">}</span> <span class="c1"># the current left bound for the regions</span>
        <span class="nv">curr_region_rbound</span> <span class="o">=</span> <span class="si">${</span><span class="nv">_regions</span><span class="p">[1]</span><span class="si">}</span> + region_inc <span class="c1"># the current right bound for the regions</span>
        
        <span class="c1"># WILL NEED THESE FOR LD MATRIX AND ONWARD</span>
        <span class="nv">iid_ph</span> <span class="o">=</span> <span class="o">[]</span>
        <span class="nv">rg_stat_SNP</span> <span class="o">=</span> <span class="o">[]</span>
        <span class="nv">phenoIID</span> <span class="o">=</span> <span class="o">[]</span>
        
        <span class="k">while</span> curr_region_lbound &lt;<span class="o">=</span> <span class="si">${</span><span class="nv">_regions</span><span class="p">[2]</span><span class="si">}</span>: <span class="c1"># since we want to increment, we want to make sure our left bound is less than max right</span>
            <span class="c1"># check to see if right bound works</span>
            <span class="k">if</span> curr_region_rbound &lt; <span class="si">${</span><span class="nv">_regions</span><span class="p">[2]</span><span class="si">}</span>:
                <span class="nv">region</span> <span class="o">=</span> <span class="o">(</span>int<span class="o">(</span>chrom<span class="o">)</span>, curr_region_lbound, curr_region_rbound<span class="o">)</span>
            <span class="k">else</span>:
                <span class="nv">region</span> <span class="o">=</span> <span class="o">(</span>int<span class="o">(</span>chrom<span class="o">)</span>, curr_region_lbound, <span class="si">${</span><span class="nv">_regions</span><span class="p">[2]</span><span class="si">}</span><span class="o">)</span>
                
            <span class="c1"># increment for the next iteration</span>
            <span class="nv">curr_region_lbound</span> <span class="o">+=</span> region_inc + <span class="m">1</span>
            <span class="nv">curr_region_rbound</span> <span class="o">+=</span> region_inc + <span class="m">1</span>
            
            <span class="nv">gwas</span> <span class="o">=</span> sumstats
            
            <span class="c1"># call and do checks on rg_stat</span>
            <span class="nv">rg_stat</span> <span class="o">=</span> regional_stats<span class="o">(</span>gwas, region<span class="o">)</span> <span class="c1"># only calling on a fraction of the region</span>
            rg_stat.index <span class="o">=</span> rg_stat.CHR.astype<span class="o">(</span>str<span class="o">)</span> + <span class="s1">&#39;_&#39;</span> + rg_stat.POS.astype<span class="o">(</span>str<span class="o">)</span> + <span class="s1">&#39;_&#39;</span> + rg_stat.REF.astype<span class="o">(</span>str<span class="o">)</span> + <span class="s1">&#39;_&#39;</span> + rg_stat.ALT.astype<span class="o">(</span>str<span class="o">)</span>
            print<span class="o">(</span>f<span class="s1">&#39;The regional summary statistics of {region[0]}_{region[1]}_{region[2]} has {len(rg_stat.index)} variants&#39;</span><span class="o">)</span>
            check_unique<span class="o">(</span>rg_stat.index, <span class="s2">&quot;Summary statistics&quot;</span><span class="o">)</span>
            
            <span class="c1"># geno, pheno, unr, and plink are defined prior to the while loop</span>
            print<span class="o">(</span>f<span class="s1">&#39;{time.strftime(&quot;%H:%M:%S&quot;, t)}: Extracting genotypes in {&quot;plink&quot; if plink else &quot;bgen&quot;} format ...&#39;</span><span class="o">)</span>
            <span class="k">if</span> plink:
                rg_bim,rg_fam,rg_bed <span class="o">=</span> plink_slice<span class="o">(</span>geno,pb<span class="o">=</span>list<span class="o">(</span>region_index<span class="o">(</span>geno<span class="o">[</span><span class="m">0</span><span class="o">]</span>,region,chrom_col<span class="o">=</span><span class="m">0</span>,pos_col<span class="o">=</span><span class="m">3</span><span class="o">)))</span>
            <span class="k">else</span>:
                rg_bim,rg_bed<span class="o">=</span>bgen_region<span class="o">(</span>region,geno,dtype<span class="o">=</span><span class="s1">&#39;float16&#39;</span><span class="o">)</span>
                <span class="nv">rg_fam</span> <span class="o">=</span> geno<span class="o">[</span><span class="m">1</span><span class="o">]</span>
            
            rg_bim.index <span class="o">=</span> rg_bim.chrom.astype<span class="o">(</span>str<span class="o">)</span> + <span class="s1">&#39;_&#39;</span> + rg_bim.pos.astype<span class="o">(</span>str<span class="o">)</span> + <span class="s1">&#39;_&#39;</span> + rg_bim.a1.astype<span class="o">(</span>str<span class="o">)</span> + <span class="s1">&#39;_&#39;</span> + rg_bim.a0.astype<span class="o">(</span>str<span class="o">)</span>
            check_unique<span class="o">(</span>rg_bim.index, <span class="s1">&#39;SNPs in reference genotype&#39;</span><span class="o">)</span>
            rg_fam.index <span class="o">=</span> rg_fam.iid
            check_unique<span class="o">(</span>rg_fam.index, <span class="s1">&#39;FAM info&#39;</span><span class="o">)</span>
            <span class="nv">rg_bed</span> <span class="o">=</span> pd.DataFrame<span class="o">(</span>rg_bed,index<span class="o">=</span>rg_bim.index,columns<span class="o">=</span>rg_fam.index<span class="o">)</span>
            <span class="nv">exclude_idx</span> <span class="o">=</span> rg_bed.index.duplicated<span class="o">(</span><span class="nv">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="o">)</span>

            <span class="nv">exc</span> <span class="o">=</span> <span class="o">[]</span>
            <span class="nv">i</span> <span class="o">=</span> <span class="m">0</span>
            <span class="k">for</span> each in exclude_idx:
                <span class="k">if</span> <span class="nv">each</span> <span class="o">==</span> True:
                    exc.append<span class="o">(</span>i<span class="o">)</span>
                <span class="nv">i</span> <span class="o">+=</span> <span class="m">1</span>
            rg_bed.drop<span class="o">(</span>exc, <span class="nv">inplace</span><span class="o">=</span>True<span class="o">)</span>
            
            print<span class="o">(</span>f<span class="s1">&#39;The regional genotype file of {region[0]}_{region[1]}_{region[2]} has {len(rg_bed.index)} variants&#39;</span><span class="o">)</span>
            <span class="k">if</span> not list<span class="o">(</span>rg_stat.index<span class="o">)==</span>list<span class="o">(</span>rg_bed.index<span class="o">)</span>:
               <span class="c1"># overlapping variants</span>
                <span class="nv">com_row_idx</span> <span class="o">=</span> rg_bed.index.intersection<span class="o">(</span>rg_stat.index<span class="o">)</span>
                <span class="k">if</span> len<span class="o">(</span>com_row_idx<span class="o">)</span> <span class="o">==</span> <span class="m">0</span>:
                    raise ValueError<span class="o">(</span><span class="s2">&quot;Variants ID between summary statistics and reference genotype are completely different&quot;</span><span class="o">)</span>

                print<span class="o">(</span>f<span class="s1">&#39;The regional genotype file ({len(rg_bed.index)} variants) and the regional summary statistics ({len(rg_stat.index)} variants) do not match with each other. The overlapping variants ({len(com_row_idx)} variants) will be selected.&#39;</span><span class="o">)</span>
                <span class="nv">rg_stat</span> <span class="o">=</span> rg_stat.loc<span class="o">[</span>com_row_idx,:<span class="o">]</span>
                <span class="nv">rg_bed</span> <span class="o">=</span> rg_bed.loc<span class="o">[</span>com_row_idx,:<span class="o">]</span>
                
                <span class="nv">temp_iid_unr</span> <span class="o">=</span> rg_fam.index.intersection<span class="o">(</span>pd.Index<span class="o">(</span>unr.IID<span class="o">))</span> <span class="c1"># iid_unr</span>
                
                pheno.index <span class="o">=</span> pheno.IID
                check_unique<span class="o">(</span>pheno.index, <span class="s2">&quot;Phenotype&quot;</span><span class="o">)</span>
                <span class="nv">temp_iid_ph</span> <span class="o">=</span> pheno.index.intersection<span class="o">(</span>rg_fam.index<span class="o">)</span> <span class="c1"># iid_ph</span>
                
                rg_bed.fillna<span class="o">(</span> rg_bed.mean<span class="o">()</span>, <span class="nv">inplace</span> <span class="o">=</span> True <span class="o">)</span>
                
                <span class="nv">temp_three_intersec</span> <span class="o">=</span> pd.Index<span class="o">(</span>temp_iid_unr<span class="o">)</span>.intersection<span class="o">(</span>temp_iid_ph<span class="o">)</span>
                
            <span class="k">if</span> region<span class="o">[</span><span class="m">1</span><span class="o">]</span> <span class="o">==</span> <span class="si">${</span><span class="nv">_regions</span><span class="p">[1]</span><span class="si">}</span>: <span class="c1"># when these two are equal it means we are at the first loop</span>
                rg_stat.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;sumstats&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> True, <span class="nv">index</span> <span class="o">=</span> True<span class="o">)</span>
                rg_bed.loc<span class="o">[</span>:,temp_iid_ph<span class="o">]</span>.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;genotype&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> True, <span class="nv">index</span> <span class="o">=</span> True<span class="o">)</span>
                rg_bed.loc<span class="o">[</span>:,temp_iid_unr<span class="o">]</span>.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;general&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span> + <span class="s1">&#39;pre_pop_ld.gz&#39;</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> True, <span class="nv">index</span> <span class="o">=</span> True<span class="o">)</span>
                rg_bed.loc<span class="o">[</span>:,temp_three_intersec<span class="o">]</span>.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;general&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span> + <span class="s1">&#39;pre_sample_ld.gz&#39;</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> True, <span class="nv">index</span> <span class="o">=</span> True<span class="o">)</span>
            <span class="k">else</span>:
                rg_stat.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;sumstats&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> False, <span class="nv">index</span> <span class="o">=</span> True, <span class="nv">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="o">)</span>
                rg_bed.loc<span class="o">[</span>:,temp_iid_ph<span class="o">]</span>.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;genotype&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> False, <span class="nv">index</span> <span class="o">=</span> True, <span class="nv">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="o">)</span>
                rg_bed.loc<span class="o">[</span>:,temp_iid_unr<span class="o">]</span>.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;general&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span> + <span class="s1">&#39;pre_pop_ld.gz&#39;</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> False, <span class="nv">index</span> <span class="o">=</span> True, <span class="nv">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="o">)</span>
                rg_bed.loc<span class="o">[</span>:,temp_three_intersec<span class="o">]</span>.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;general&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span> + <span class="s1">&#39;pre_sample_ld.gz&#39;</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> False, <span class="nv">index</span> <span class="o">=</span> True, <span class="nv">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="o">)</span>
                
            <span class="k">for</span> each in temp_iid_ph: <span class="c1">#order based on pheno</span>
                iid_ph.append<span class="o">(</span>each<span class="o">)</span>
            <span class="k">for</span> each in rg_stat.SNP:
                rg_stat_SNP.append<span class="o">(</span>each<span class="o">)</span>
            <span class="k">for</span> each in pheno.IID:
                phenoIID.append<span class="o">(</span>each<span class="o">)</span>
                
            gc.collect<span class="o">()</span>
                
        <span class="c1"># LD_matrix for pop_ld_approx</span>
        <span class="nv">snps</span> <span class="o">=</span> pd.read_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;general&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span> + <span class="s1">&#39;pre_pop_ld.gz&#39;</span>, <span class="nv">compression</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span>, <span class="nv">header</span><span class="o">=</span><span class="m">0</span>, <span class="nv">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span>, <span class="nv">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span>, <span class="nv">index_col</span><span class="o">=</span><span class="m">0</span><span class="o">)</span>
        <span class="c1">#snps.fillna( snps.mean(), inplace = True )</span>
        
        <span class="k">for</span> i in range<span class="o">(</span>len<span class="o">(</span>snps.index<span class="o">))</span>:
            <span class="nv">corr</span> <span class="o">=</span> snps.corrwith<span class="o">(</span>snps.iloc<span class="o">[</span>i<span class="o">]</span>, <span class="nv">axis</span><span class="o">=</span><span class="m">1</span><span class="o">)</span>.to_frame<span class="o">()</span>.transpose<span class="o">()</span>
            corr.index <span class="o">=</span> <span class="o">[</span>rg_stat_SNP<span class="o">[</span>i<span class="o">]]</span>
            
            <span class="k">if</span> <span class="nv">i</span> <span class="o">==</span> <span class="m">0</span>:
                corr.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;pld&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> True, <span class="nv">index</span> <span class="o">=</span> True<span class="o">)</span>
            <span class="k">else</span>:
                corr.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;pld&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> False, <span class="nv">index</span> <span class="o">=</span> True, <span class="nv">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="o">)</span>
                
        gc.collect<span class="o">()</span>
                
        <span class="c1"># LD matrix for sample_ld_approx</span>
        <span class="nv">snps</span> <span class="o">=</span> pd.read_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;general&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span> + <span class="s1">&#39;pre_sample_ld.gz&#39;</span>, <span class="nv">compression</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span>, <span class="nv">header</span><span class="o">=</span><span class="m">0</span>, <span class="nv">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span>, <span class="nv">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span>, <span class="nv">index_col</span><span class="o">=</span><span class="m">0</span><span class="o">)</span>
        <span class="c1">#snps.fillna( snps.mean(), inplace = True )</span>
        
        <span class="k">for</span> i in range<span class="o">(</span>len<span class="o">(</span>snps.index<span class="o">))</span>:
            <span class="nv">corr</span> <span class="o">=</span> snps.corrwith<span class="o">(</span>snps.iloc<span class="o">[</span>i<span class="o">]</span>, <span class="nv">axis</span><span class="o">=</span><span class="m">1</span><span class="o">)</span>.to_frame<span class="o">()</span>.transpose<span class="o">()</span>
            corr.index <span class="o">=</span> <span class="o">[</span>rg_stat_SNP<span class="o">[</span>i<span class="o">]]</span>
            
            <span class="k">if</span> <span class="nv">i</span> <span class="o">==</span> <span class="m">0</span>:
                corr.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;sld&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> True, <span class="nv">index</span> <span class="o">=</span> True<span class="o">)</span>
            <span class="k">else</span>:
                corr.to_csv<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;sld&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span>, <span class="nv">sep</span> <span class="o">=</span> <span class="s2">&quot;\t&quot;</span>, <span class="nv">header</span> <span class="o">=</span> False, <span class="nv">index</span> <span class="o">=</span> True, <span class="nv">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="o">)</span>
        
        gc.collect<span class="o">()</span>
            
        
        <span class="c1"># genotypes in the sample of a specific phenotype with ordering match</span>
        <span class="k">if</span> not <span class="nv">iid_ph</span> <span class="o">==</span> phenoIID:
            print<span class="o">(</span><span class="s1">&#39;Warning: Some samples with phenotype do not have genotypes&#39;</span><span class="o">)</span>
        
        import os
        os.remove<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;general&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span> + <span class="s1">&#39;pre_pop_ld.gz&#39;</span><span class="o">)</span>
        os.remove<span class="o">(</span><span class="si">${</span><span class="nv">_output</span><span class="p">[</span><span class="s1">&#39;general&#39;</span><span class="p">]:</span><span class="nv">r</span><span class="si">}</span> + <span class="s1">&#39;pre_sample_ld.gz&#39;</span><span class="o">)</span>
        
    <span class="k">if</span> <span class="nv">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span>:
        main<span class="o">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<hr>
&copy 2020 Diana Cornejo at Center for Statistical Genetics, Sergievsky Center, Columbia University VP&S
<p><small>Exported from <a href="http://github.com/dianacornejo/pleiotropy_UKB/blob/469a2f5bc64846f003d833901f6c8467336f3a7f/workflow/Region_Extraction_5.ipynb"><code>workflow/Region_Extraction_5.ipynb</code></a> committed by tfabiha on Fri Feb 5 01:56:58 2021 <a href="http://github.com/dianacornejo/pleiotropy_UKB/commit/469a2f5bc64846f003d833901f6c8467336f3a7f">revision 1, 469a2f5</a> <a href="https://stephenslab.github.io/ipynb-website/notes.html#Note-about-commit-ids"><span class="fa fa-question-circle"></span></a></small></p>
</div>
</div>
</body>
</html>
